# SelfOpt — MVP Technical Execution Plan

## 0. Purpose

This document defines the complete technical execution plan for the SelfOpt MVP.

The MVP must:

- Connect to a GitHub repository
- Automatically detect install/build/test commands
- Run a reproducible baseline
- Continuously scan and generate optimization proposals
- Validate every candidate deterministically
- Surface only evidence-backed improvements
- Allow one-click PR creation
- Store all state and artifacts in Supabase
- Be fully covered by exhaustive testing

SelfOpt must be deterministic, measurable, and trustworthy.

---

# 1. System Architecture Overview

SelfOpt consists of three primary layers:

1. **Control Plane** (Next.js + FastAPI + Supabase)
2. **Execution Plane** (Sandboxed Runner Containers)
3. **GitHub Integration Layer**

High-level flow:

1. User installs GitHub App.
2. Repository metadata stored in Supabase Postgres.
3. Baseline run executes in sandbox.
4. Continuous optimization cycles run on schedule.
5. Validated proposals stored in Supabase.
6. User reviews proposals and opens PR.

---

# 2. Tech Stack

## Frontend (Dashboard)

- Next.js (App Router)
- TypeScript
- Tailwind CSS
- shadcn/ui
- Supabase Auth
- Supabase Realtime (for run updates)

Directory structure:

```

apps/web/
app/
components/
lib/
styles/
tests/

```

---

## Backend (Control Plane API)

- FastAPI (Python)
- Pydantic v2
- Supabase Postgres (primary database)
- Supabase Storage (artifact storage)
- Redis (job queue + locking)
- Celery (background workers)
- OpenTelemetry + Sentry

Directory structure:

```

apps/api/
app/
core/
db/
github/
repos/
runs/
engine/
proposals/
artifacts/
common/
tests/

```

---

## Execution Plane (Runner)

- Ephemeral Docker containers
- Node LTS installed
- git
- pnpm / yarn / npm
- CPU and memory limited
- No secrets exposed
- Network restricted (allow npm + GitHub only)

Directory:

```

apps/runner/
runner/
detector/
scanner/
patchgen/
validator/
packaging/
sandbox/
tests/

```

---

# 3. Database — Supabase Postgres

Supabase Postgres is the **single source of truth** for all application state.

FastAPI is the authoritative backend that writes and reads from Supabase.

---

## Core Tables

### users
- id (uuid)
- email
- created_at

### organizations
- id
- name
- owner_id

### repositories
- id
- org_id
- github_repo_id
- default_branch
- package_manager
- install_cmd
- build_cmd
- test_cmd
- bench_config (jsonb)
- created_at

### baselines
- id
- repo_id
- sha
- metrics (jsonb)
- environment_fingerprint (jsonb)
- created_at

### runs
- id
- repo_id
- sha
- status (enum)
- compute_minutes
- created_at

### opportunities
- id
- run_id
- type
- location
- rationale
- risk_score

### attempts
- id
- opportunity_id
- diff
- validation_result (jsonb)
- status (accepted/rejected)

### proposals
- id
- run_id
- diff
- summary
- metrics_before (jsonb)
- metrics_after (jsonb)
- risk_score
- created_at
- pr_url (nullable)

### artifacts
- id
- proposal_id
- storage_path
- type (log / trace / bench / diff)
- created_at

### settings
- repo_id
- compute_budget_minutes
- max_proposals_per_run
- schedule (cron string)

All dynamic fields stored as JSONB.

---

# 4. Storage — Supabase Storage

Supabase Storage replaces AWS S3 entirely.

Used for:

- Baseline outputs
- Benchmark results
- Validation logs
- Agent traces
- Patch diffs
- Proposal evidence bundles

---

## Storage Bucket Structure

Create a bucket:

```

artifacts

```

Structure:

```

artifacts/
repos/{repo_id}/
runs/{run_id}/
baseline.json
bench_output.json
logs.txt
trace.json
proposals/{proposal_id}/
diff.patch
validation.json
logs.txt

```

---

## Storage Security Model

- Only backend service role uploads artifacts.
- Users retrieve artifacts via signed URLs generated by FastAPI.
- Row-level security ensures users only access repos they belong to.
- Service key never exposed to frontend.

---

# 5. Repository Auto-Detection

Detection sources (priority order):

1. `.github/workflows/*.yml`
2. `package.json`
3. lockfiles (pnpm/yarn/npm)
4. framework indicators (next.config.js, nest-cli.json)
5. fallback heuristics

Outputs persisted in database:

- package_manager
- install_cmd
- build_cmd
- test_cmd
- bench_config
- confidence score

If test detection fails:
- Proposal creation disabled until user confirms command.

---

# 6. Optimization Engine

Each optimization cycle creates a `runs` record.

---

## Phase A — Baseline

Runner executes:

1. install
2. build (if present)
3. typecheck (if present)
4. tests
5. benchmark (script or HTTP mode)

Baseline metrics stored in `baselines`.

---

## Phase B — Scan

Scanner generates opportunities using:

- tree-sitter AST parsing
- ripgrep patterns
- TS diagnostics
- ESLint
- complexity metrics
- framework-specific heuristics

Results stored in `opportunities`.

---

## Phase C — Patch Generation

Two systems:

### Template-based patches
- Set vs array membership
- Memoization wrappers
- Remove redundant parsing
- Loop simplification
- Dead code removal (if validated)

### LLM-guided micro-refactors
Strict constraints:
- ≤5 files
- ≤200 lines changed
- No dependency updates
- No config edits
- No test edits

All attempts stored in `attempts`.

---

## Phase D — Validation Gates

Every candidate must pass:

1. Build
2. Typecheck
3. Tests
4. Benchmark comparison
5. Risk threshold

Performance must:
- Improve ≥ 3%
- Exceed statistical noise threshold

Rejected attempts are logged but not surfaced.

---

## Phase E — Proposal Packaging

Accepted candidates become `proposals`.

Each proposal includes:

- Diff
- Before/after metrics
- Validation logs
- Risk score
- Agent trace

Artifacts uploaded to Supabase Storage.
Artifact metadata stored in `artifacts`.

User can click “Create PR”:

- New branch created
- Commit patch
- PR opened
- `pr_url` updated in database

---

# 7. Continuous Execution

Default schedule:
- Nightly per repo
- Manual run trigger

Budget limits stored in `settings`.

Auto pause triggers:
- Repeated setup failures
- Flaky tests
- Repo cannot build

Run status updated in `runs`.

---

# 8. Testing Strategy (Comprehensive)

Principle:

No such thing as too many tests.

Test structure mirrors source structure.

---

## 8.1 Database Tests (Supabase)

- Migration tests
- Constraint tests
- JSON schema validation
- Transaction tests

Use Supabase CLI locally for integration testing.

---

## 8.2 Backend Tests (FastAPI)

Framework:
- pytest
- pytest-asyncio
- hypothesis

Test layers:

### Unit
- Detector logic
- Scanner rules
- Risk scoring
- Metric comparison
- Proposal packaging
- API validation

### Integration
- FastAPI + Supabase DB
- Redis queue
- Supabase Storage upload/download
- GitHub API mocks

---

## 8.3 Runner Tests

- Detector tests
- Scanner tests
- Patch template tests
- Validation gate tests
- Metric comparison tests
- Full optimization simulation

Golden tests ensure stable outputs.

---

## 8.4 Frontend Tests

- Component tests (Vitest)
- Page tests
- Supabase client mocks
- Playwright E2E:
  - Connect repo
  - View baseline
  - View proposal
  - Create PR

---

# 9. Local Development

Use Supabase CLI:

```

supabase start

```

Local stack includes:

- Postgres
- Storage
- Auth
- Realtime

Docker Compose services:

- web
- api
- redis
- supabase
- runner

Entire system runs locally without AWS.

---

# 10. CI Pipeline

CI must:

1. Run backend unit tests
2. Run DB migration tests
3. Run runner tests
4. Run frontend tests
5. Run E2E tests
6. Lint + typecheck

No merges without full pass.

---

# 11. Definition of Done

MVP complete when:

- Repo connects without manual configuration
- Baseline stored in Supabase
- Optimization cycle generates proposals
- Proposals validated deterministically
- PR can be created
- Artifacts stored in Supabase Storage
- Full test suite passes in CI

---

# 12. Architectural Principles

- Supabase Postgres is the single source of truth.
- Supabase Storage handles all artifacts.
- FastAPI owns business logic.
- Runner is stateless and reports back.
- LLM proposes; validation decides.
- Evidence is mandatory.
- Everything is logged.
- Everything is tested.
- Nothing auto-merges in MVP.

SelfOpt is a continuous engineering improvement system that runs safely, transparently, and measurably.