"""Types for the LLM agent layer.

`AgentOpportunity` and `AgentPatch` are the agent equivalents of the
scanner's `Opportunity` and patchgen's `PatchResult` — but each carries
a `ThinkingTrace` so the reasoning that produced them is preserved.
"""

from dataclasses import dataclass, field
from typing import Optional, TYPE_CHECKING

from runner.llm.types import ThinkingTrace

if TYPE_CHECKING:
    from runner.validator.types import CandidateResult


@dataclass
class AgentOpportunity:
    """An optimisation opportunity identified by the LLM discovery agent.

    Carries the model's full reasoning trace so the UI can show the
    developer exactly why the agent flagged this location.

    `approaches` holds 1–3 concrete implementation strategies returned by
    the discovery LLM. `approach` is a backward-compat property returning
    the first entry.
    """

    type: str                      # e.g. "performance", "tech_debt"
    location: str                  # "<file>:<line>" (repo-relative)
    rationale: str                 # Why this is a problem
    risk_level: str                # "low" | "medium" | "high"
    approaches: list[str] = field(default_factory=list)  # Implementation strategies
    affected_lines: int = 0        # Estimated lines the fix will touch
    thinking_trace: Optional[ThinkingTrace] = None  # Discovery reasoning

    @property
    def approach(self) -> str:
        """First (or only) approach description — backward-compat accessor."""
        return self.approaches[0] if self.approaches else ""

    @property
    def risk_score(self) -> float:
        """Numeric risk score compatible with the scanner Opportunity type."""
        return {"low": 0.2, "medium": 0.5, "high": 0.8}.get(self.risk_level, 0.5)

    def to_dict(self) -> dict:
        return {
            "type": self.type,
            "location": self.location,
            "rationale": self.rationale,
            "approaches": self.approaches,
            "risk_level": self.risk_level,
            "affected_lines": self.affected_lines,
            "risk_score": self.risk_score,
            "thinking_trace": self.thinking_trace.to_dict() if self.thinking_trace else None,
        }


@dataclass
class AgentPatch:
    """A patch produced by the LLM patch-generation agent.

    Structurally equivalent to `PatchResult` but carries additional
    agent metadata. The `diff` field is a unified diff string ready for
    `patch -p1 -f`.
    """

    diff: str
    explanation: str
    touched_files: list[str]
    estimated_lines_changed: int = 0
    title: str = ""  # Short commit-subject title generated by the LLM
    thinking_trace: Optional[ThinkingTrace] = None  # Patch generation reasoning

    def to_dict(self) -> dict:
        return {
            "diff": self.diff,
            "explanation": self.explanation,
            "touched_files": self.touched_files,
            "estimated_lines_changed": self.estimated_lines_changed,
            "title": self.title,
            "thinking_trace": self.thinking_trace.to_dict() if self.thinking_trace else None,
        }


@dataclass
class PatchVariantResult:
    """Result of one patch approach attempt for a single opportunity.

    The orchestrator generates one `PatchVariantResult` per approach string
    in `AgentOpportunity.approaches`. After all approaches are validated,
    `_select_best_variant` marks exactly one variant as `is_selected=True`.
    """

    approach_index: int
    approach_description: str
    patch: Optional[AgentPatch]
    candidate_result: "CandidateResult"
    is_selected: bool = False
    selection_reason: str = ""

    def to_dict(self) -> dict:
        return {
            "approach_index": self.approach_index,
            "approach_description": self.approach_description,
            "diff": self.patch.diff if self.patch else "",
            "patch_trace": (
                self.patch.thinking_trace.to_dict()
                if self.patch and self.patch.thinking_trace
                else None
            ),
            "is_selected": self.is_selected,
            "selection_reason": self.selection_reason,
            "validation_result": (
                self.candidate_result.to_dict() if self.candidate_result else None
            ),
            "metrics_after": _metrics_after_from_candidate(self.candidate_result),
        }


def _metrics_after_from_candidate(candidate: "CandidateResult") -> Optional[dict]:
    """Extract the metrics_after dict from the candidate's decisive attempt."""
    if not candidate or not candidate.attempts:
        return None
    decisive = candidate.attempts[-1]
    if decisive.pipeline_result:
        return decisive.pipeline_result.to_dict()
    return None


@dataclass
class AgentRun:
    """Aggregated output of a full agent cycle for one run.

    Contains all discovered opportunities and their associated patches
    (or failure records when patch generation was not possible).
    """

    opportunities: list[AgentOpportunity] = field(default_factory=list)
    patches: list[Optional[AgentPatch]] = field(default_factory=list)
    # Error messages per opportunity index (None = success)
    errors: list[Optional[str]] = field(default_factory=list)
    model: str = ""
    provider: str = ""

    @property
    def successful_patch_count(self) -> int:
        return sum(1 for p in self.patches if p is not None)
